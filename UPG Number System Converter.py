def number_system_converter(number, start_base, end_base):
    # 2  -> 8, 10, 16;
    # 8  -> 2, 10, 16;
    # 10 -> 2, 8,  16;
    # 16 -> 2, 8,  10;

    # Если начальная система счисления меньше, чем конечная:
    if (start_base < end_base):
        # 2 -> 8, 10, 16;
        # 8 -> 10, 16;
        # 10 -> 16;

        # Зададим переменную для будущего ответа
        answer = 0

        # Для перевода: 2 -> 10; 8 -> 10
        # Алгоритм: СОСТАВЛЕНИЕ И РЕШЕНИЕ ПОЛИНОМА
        
        # Если число целое
        if (str(number).find('.') == -1):
            # Степень start_base
            bit_number = 0

            # Перебираем все цифры в исходном числе
            while (number != 0):
                # Рассмотрим на двух примерах: (1101, 2, 10) и (432, 8, 10)
                intermediate_answer = (number % 10) * (start_base ** bit_number)
                    # 1.1) int_ans = (1101 % 10) * (2 ** 0) = 1 * 2**0 = 1 | # 2.1) int_ans = (432 % 10) * (8 ** 0) = 2 * 8**0 = 2
                    # 1.2) int_ans = (110  % 10) * (2 ** 1) = 0 * 2**1 = 0 | # 2.2) int_ans = (43  % 10) * (8 ** 1) = 3 * 8**1 = 24
                    # 1.3) int_ans = (11   % 10) * (2 ** 2) = 1 * 2**2 = 4 | # 2.3) int_ans = (4   % 10) * (8 ** 2) = 4 * 8**2 = 256
                    # 1.4) int_ans = (1    % 10) * (2 ** 3) = 1 * 2**3 = 8
                answer += intermediate_answer
                    # 1.1) ans = 0 + 1 = 1                                 | # 2.1) ans = 0  + 2 = 2
                    # 1.2) ans = 1 + 0 = 1                                 | # 2.2) ans = 2  + 24 = 26
                    # 1.3) ans = 1 + 4 = 5                                 | # 2.3) ans = 26 + 256 = 282
                    # 1.4) ans = 5 + 8 = 13
                number //= 10
                    # 1.1) num = 1101 // 10 = 110                          | # 2.1) num = 432 // 10 = 43
                    # 1.2) num = 110  // 10 = 11                           | # 2.2) num = 43  // 10 = 4
                    # 1.3) num = 11   // 10 = 1                            | # 2.3) num = 4   // 10 = 0
                    # 1.4) num = 1    // 10 = 0
                bit_number += 1
                    # 1.1) bit_num = 0 + 1 = 1                             | # 2.1) bit_num = 0 + 1 = 1
                    # 1.2) bit_num = 1 + 1 = 2                             | # 2.2) bit_num = 1 + 1 = 2
                    # 1.3) bit_num = 2 + 1 = 3                             | # 2.1) bit_num = 2 + 1 = 3
                    # 1.4) bit_num = 3 + 1 = 4
            return answer
        
        # Если число дробное
        else:
            # Начнём с дробной части
            bit_number = -1
            # Выпишем отдельно дробную часть
            # Округляем разницу между всем числом и его целой частью до количества знаков: длина числа - длина числа до точки, включительно
            # Если просто искать вышеупомянутую разницу, то могут возникать ошибки в следствие неидеальной арифметики чисел с плавающей точкой
            fraction_number = round((number - (number // 1)), ((len(str(number)) - str(number).find('.')) - 1))
            # Прибавляем числа по правилу:
            # Перебираем числа, стоящие после точки. Аргумент range = их количеству (находили выше)
            for i in range((len(str(number)) - str(number).find('.')) - 1):
                # Рассмотрим на двух примерах: (1101.01, 2, 10) и (432.2, 8, 10)
                intermediate_answer = (fraction_number * 10 // 1) * (start_base ** bit_number)
                    # 1.1) int_ans = (0.01 * 10 // 1) * (2 ** -1) = (0.1 // 1) * 1 / 2 = 0 * 0.5   = 0    
                    # 1.2) int_ans = (0.1  * 10 // 1) * (2 ** -2) = (1   // 1) * 1 / 4 = 1 * 0.25  = 0.25
                    # 2.1) int_ans = (0.2 * 10 // 1)  * (8 ** -1) = (2   // 1) * 1 / 8 = 2 * 0.125 = 0.25
                answer += intermediate_answer
                    # 1.1) ans = 0 + 0    = 0    
                    # 1.2) ans = 0 + 0.25 = 0.25
                    # 2.1) ans = 0 + 0.25 = 0.25
                fraction_number = fraction_number * 10 - fraction_number * 10 // 1
                    # 1.1) frac_num = (0.01 * 10) - (0.01 * 10 // 1) = 0.1 - (0.1 // 1) = 0.1 - 0 = 0.1   
                    # 1.2) frac_num = (0.1  * 10) - (0.1  * 10 // 1) = 1   - (1   // 1) = 1   - 1 = 0
                    # 2.1) frac_num = (0.2  * 10) - (0.2  * 10 // 1) = 2   - (2   // 1) = 2   - 2 = 0
                bit_number -= 1
                    # 1.1) bit_num = -1 - 1 = -2 
                    # 1.2) bit_num = -2 - 1 = -3
                    # 2.1) bit_num = -1 - 1 = -2
            
            # Вернёмся к целой части
            # Делаем по полной аналогии с алгоритмом для целого числа
            number //= 1
            bit_number = 0
            while (number != 0):
                intermediate_answer = (number % 10) * (start_base ** bit_number)
                answer += intermediate_answer
                number //= 10
                bit_number += 1
            
            return answer
                    
